[33mcommit 0dee2034b678a748a98b0705ecbd2342a9194ad5[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mmain[m[33m, [m[1;31morigin/main[m[33m, [m[1;31morigin/HEAD[m[33m)[m
Author: Julius <founder.haail@gmail.com>
Date:   Sat Jan 3 14:44:05 2026 +0000

    Stop Week View from generating plans: Add peek mode to /api/today-plan and update UI
---
 api.py                    | 80 [32m+++++++++++++++++++++++++++++++++++++++++++[m[31m----[m
 evidence/updatedifflog.md | 29 [32m+++++++++[m[31m--------[m
 othello_ui.html           | 16 [32m+++++++++[m[31m-[m
 3 files changed, 103 insertions(+), 22 deletions(-)

[1mdiff --git a/api.py b/api.py[m
[1mindex 5327dbd5..a681fcfa 100644[m
[1m--- a/api.py[m
[1m+++ b/api.py[m
[36m@@ -5389,6 +5389,65 @@[m [mdef get_today_plan():[m
         plan_date = _get_local_today(user_id)[m
         logger.info("API: today-plan using local_today=%s", plan_date)[m
 [m
[32m+[m[32m    # Peek mode: Read-only, no generation, no merging, no persistence[m
[32m+[m[32m    peek_mode = args.get("peek") == "1"[m
[32m+[m[32m    if peek_mode:[m
[32m+[m[32m        if not args.get("plan_date"):[m
[32m+[m[32m             return api_error("VALIDATION_ERROR", "peek_requires_plan_date", 400)[m
[32m+[m[41m        [m
[32m+[m[32m        # Try to load existing plan row[m
[32m+[m[32m        plan_repo = comps["plan_repository"][m
[32m+[m[32m        plan_row = plan_repo.get_plan_by_date(user_id, plan_date)[m
[32m+[m[41m        [m
[32m+[m[32m        if not plan_row:[m
[32m+[m[32m            # Return empty stub[m
[32m+[m[32m            return jsonify({[m
[32m+[m[32m                "plan": {[m
[32m+[m[32m                    "date": plan_date.isoformat(),[m
[32m+[m[32m                    "sections": {"routines": [], "goal_tasks": [], "optional": []},[m
[32m+[m[32m                    "mood_context": {},[m
[32m+[m[32m                    "_plan_source": "empty_stub"[m
[32m+[m[32m                }[m
[32m+[m[32m            })[m
[32m+[m[41m            [m
[32m+[m[32m        # Load full plan with items[m
[32m+[m[32m        # Reuse day_planner logic but bypass generation/merging[m
[32m+[m[32m        # We can use get_today_plan with force_regen=False, but we must ensure it doesn't generate if missing.[m
[32m+[m[32m        # However, get_today_plan WILL generate if missing.[m
[32m+[m[32m        # So we manually construct the response from the row + items.[m
[32m+[m[41m        [m
[32m+[m[32m        # Re-fetch with items using repository helper if available, or manual construction[m
[32m+[m[32m        # Since we don't have a clean "load full plan" repo method exposed here easily without duplicating logic,[m
[32m+[m[32m        # we will use a lightweight reconstruction similar to what DayPlanner does, but strictly read-only.[m
[32m+[m[41m        [m
[32m+[m[32m        items = plan_repo.get_plan_items(plan_row["id"])[m
[32m+[m[32m        # Group items[m
[32m+[m[32m        sections = {"routines": [], "goal_tasks": [], "optional": []}[m
[32m+[m[32m        for item in items:[m
[32m+[m[32m            sec = item.get("section_hint") or "routines"[m
[32m+[m[32m            # Map 'any' to routines for legacy compat, or keep as is?[m[41m [m
[32m+[m[32m            # DayPlanner logic: routines go to 'routines', goal_tasks to 'goal_tasks'[m
[32m+[m[32m            # We'll just map by type/source_kind for safety[m
[32m+[m[32m            kind = item.get("type")[m
[32m+[m[32m            source_kind = item.get("source_kind")[m
[32m+[m[41m            [m
[32m+[m[32m            # Simple mapping matching DayPlanner.get_today_plan logic roughly[m
[32m+[m[32m            if kind == "routine" or kind == "routine_step" or source_kind == "routine":[m
[32m+[m[32m                sections["routines"].append(item)[m
[32m+[m[32m            elif kind == "goal_task" or source_kind == "goal_task":[m
[32m+[m[32m                sections["goal_tasks"].append(item)[m
[32m+[m[32m            else:[m
[32m+[m[32m                sections["optional"].append(item)[m
[32m+[m[41m                [m
[32m+[m[32m        plan_data = {[m
[32m+[m[32m            "id": plan_row["id"],[m
[32m+[m[32m            "date": plan_row["plan_date"].isoformat(),[m
[32m+[m[32m            "sections": sections,[m
[32m+[m[32m            "mood_context": plan_row.get("mood_context") or {},[m
[32m+[m[32m            "_plan_source": "db_peek"[m
[32m+[m[32m        }[m
[32m+[m[32m        return jsonify({"plan": plan_data})[m
[32m+[m
     try:[m
         plan = othello_engine.day_planner.get_today_plan([m
             user_id,[m
[36m@@ -6593,9 +6652,15 @@[m [mdef rebuild_today_plan():[m
         return error[m
     data = request.get_json() or {}[m
     mood_context = data.get("mood_context") or data[m
[32m+[m[32m    local_today = _get_local_today(user_id)[m
     try:[m
[31m-        plan = othello_engine.day_planner.rebuild_today_plan(user_id, mood_context=mood_context)[m
[31m-        logger.info("API: Rebuilt today plan on demand")[m
[32m+[m[32m        plan = othello_engine.day_planner.get_today_plan([m
[32m+[m[32m            user_id,[m
[32m+[m[32m            mood_context=mood_context,[m
[32m+[m[32m            force_regen=True,[m
[32m+[m[32m            plan_date=local_today,[m
[32m+[m[32m        )[m
[32m+[m[32m        logger.info("API: Rebuilt today plan on demand for %s", local_today)[m
         return jsonify({"plan": plan})[m
     except Exception as exc:[m
         logger.error(f"API: Failed to rebuild plan: {exc}", exc_info=True)[m
[36m@@ -7423,16 +7488,17 @@[m [mdef _ensure_today_plan_id(user_id: str) -> Optional[int]:[m
     comps = get_agent_components()[m
     othello_engine = comps["othello_engine"][m
     plan_repository = comps["plan_repository"][m
[32m+[m[32m    local_today = _get_local_today(user_id)[m
 [m
     def _fetch_plan_row() -> Optional[Dict[str, Any]]:[m
[31m-        return plan_repository.get_plan_by_date(user_id, date.today())[m
[32m+[m[32m        return plan_repository.get_plan_by_date(user_id, local_today)[m
 [m
     # Try existing row[m
     today_row = _fetch_plan_row()[m
     if not today_row:[m
         # Generate (or rebuild) and persist a plan row for today[m
         try:[m
[31m-            othello_engine.day_planner.rebuild_today_plan(user_id)[m
[32m+[m[32m            othello_engine.day_planner.get_today_plan(user_id, force_regen=True, plan_date=local_today)[m
         except Exception as exc:[m
             logger.warning("API: failed to rebuild plan before applying insight: %s", exc)[m
         today_row = _fetch_plan_row()[m
[36m@@ -7501,10 +7567,12 @@[m [mdef _append_goal_task_to_plan(user_id: str, plan_item: dict) -> bool:[m
     Returns True if appended, False if skipped (e.g., duplicate).[m
     """[m
     logger = logging.getLogger("API.Insights")[m
[32m+[m[32m    local_today = _get_local_today(user_id)[m
     try:[m
         plan = othello_engine.day_planner.get_today_plan([m
             user_id,[m
             force_regen=False,[m
[32m+[m[32m            plan_date=local_today,[m
         )[m
     except Exception as exc:[m
         logger.warning("API: failed to load plan before appending insight task: %s", exc, exc_info=True)[m
[36m@@ -7524,7 +7592,7 @@[m [mdef _append_goal_task_to_plan(user_id: str, plan_item: dict) -> bool:[m
 [m
     goal_tasks.append(plan_item)[m
     try:[m
[31m-        othello_engine.day_planner._persist_plan(user_id, date.today(), plan)  # type: ignore[attr-defined][m
[32m+[m[32m        othello_engine.day_planner._persist_plan(user_id, local_today, plan)  # type: ignore[attr-defined][m
     except Exception as exc:[m
         logger.warning("API: failed to persist plan after appending insight task: %s", exc, exc_info=True)[m
         return False[m
[36m@@ -7534,7 +7602,7 @@[m [mdef _append_goal_task_to_plan(user_id: str, plan_item: dict) -> bool:[m
         label = meta.get("label") or pla